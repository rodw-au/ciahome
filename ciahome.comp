component ciahome "Ethercat cia402 homing module";

description """
Example of a homing module buildable with halcompile.
Demonstrates required code for #includes, function definitions, etc.

An  actual homing scheme is \\fBnot\\fR implemented but all necessary
functions are included as skeleton code.   (All joints are
effectively homed at all times and cannot be unhomed).

See the source code file: src/emc/motion/homing.c for the baseline
implementation that includes all functions for the default \\fBhomemod\\fR
module.

To avoid updates that overwrite homecomp.comp, best practice is
to rename the file and its component name (example:
\\fBuser_homecomp.comp, user_homecomp\\fR).

The (renamed) component can be built and installed with
halcompile and then substituted for the default homing module
(\\fBhomemod\\fR) using:\n
  $ linuxcnc \\fB-m user_homecomp\\fR someconfig.ini\n
or by inifile setting: \\fB[EMCMOT]HOMEMOD=user_homecomp\\fR

\\fBNote:\\fRIf using a deb install:\n
1) halcompile is provided by the package linuxcnc-dev\n
2) This source file for BRANCHNAME (master,2.9,etc) is downloadable from github:\n
https://github.com/LinuxCNC/linuxcnc/blob/BRANCHNAME/src/hal/components/homecomp.comp
""";
/*
cia402 Homing mode and homing parameters are defined and configured in your ethercat config.xml file per this example
  <sdoConfig idx="6098" subIdx="0"><sdoDataRaw data ="11 00"/></sdoConfig>  <!-- Home mode 17 -->
  <sdoConfig idx="607C" subIdx="0"><sdoDataRaw data ="00 00"/></sdoConfig>  <!-- Home offset 0  -->
  <sdoConfig idx="609A" subIdx="0"><sdoDataRaw data ="F4 01"/></sdoConfig>  <!-- Home accelleration 500 -->
  <sdoConfig idx="6099" subIdx="01"><sdoDataRaw data ="C4 09"/></sdoConfig>  <!-- Home fast speed 2500-->
  <sdoConfig idx="6099" subIdx="02"><sdoDataRaw data ="F4 01"/></sdoConfig>  <!-- Home slow speed 500 -->

*/
pin out bit is_module=1; //one pin is required to use halcompile)

license "GPL";
option  homemod;
option  extra_setup;
;;

#include "motion.h"
#include "homing.h"
#include "hal.h"
#include "rtapi.h"
#include "rtapi_math.h"
#include "time.h"
#include <stdint.h>

#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
typedef enum {
  HOME_IDLE = 0,
  HOME_START,// 1
  HOME_UNLOCK,// 2
  HOME_UNLOCK_WAIT,// 3
  HOME_INITIAL_BACKOFF_START,// 4
  HOME_INITIAL_BACKOFF_WAIT,// 5
  HOME_INITIAL_SEARCH_START,// 6
  HOME_INITIAL_SEARCH_WAIT,// 7
  HOME_SET_COARSE_POSITION,// 8
  HOME_FINAL_BACKOFF_START,// 9
  HOME_FINAL_BACKOFF_WAIT,// 10
  HOME_RISE_SEARCH_START,// 11
  HOME_RISE_SEARCH_WAIT,// 12
  HOME_FALL_SEARCH_START,// 13
  HOME_FALL_SEARCH_WAIT,// 14
  HOME_SET_SWITCH_POSITION,// 15
  HOME_INDEX_ONLY_START,// 16
  HOME_INDEX_SEARCH_START,// 17
  HOME_INDEX_SEARCH_WAIT,// 18
  HOME_SET_INDEX_POSITION,// 19
  HOME_FINAL_MOVE_START,// 20
  HOME_FINAL_MOVE_WAIT,// 21
  HOME_LOCK,// 22
  HOME_LOCK_WAIT,// 23
  HOME_FINISHED,// 24
  HOME_ABORT// 25
} home_state_t;

//CiA IOs

//constants
#define FAULT_AUTORESET_DELAY_NS 100000000LL
#define OPMODE_CYCLIC_POSITION 8
#define OPMODE_CYCLIC_VELOCITY 9
#define OPMODE_HOMING 6
#define OPMODE_NONE 0
#define HEARTBEAT 0.25
#define DEBUG

typedef  enum HOME_STATE{HOME_TRIGGER, HOME_CONFIRM, HOME_SEEKING} cia_home_state_t   ;  // For cia

/*
inputs from drive
-----------------
pin in unsigned statusword        "Drives CiA402 Statusword, index 0x6041";
pin in signed opmode_display      "Drives Modes of Operation feedback register, index 0x6061";
pin in signed drv_actual_position "Drives actual Position, index 0x6064";
pin in signed drv_actual_velocity "Drives actual Velocity, index 0x606C";

outputs to drive
----------------
pin out unsigned controlword    "Drives CIA402 Controlword, index 0x6040";
pin out signed opmode           "Drives Modes of Operation Input, index 0x6060";
pin out signed drv_target_position  "Position command to the drive, index 0x607A";
pin out signed drv_target_velocity  "Velocity command to the drive, index 0x60FF";

Control IOs
-----------
pin in bit enable     "true enables the Drive";
pin in float pos_cmd  "target Position, from Motion or PID";
pin in float velocity_cmd "target Velocity, from Motion or PID";

pin out float pos_fb      "Position feedback, scaled";
pin out float velocity_fb "Velocity feedback scaled";
pin out bit drv_fault     "true indicates an Drive Error";
Homing IOs
----------
pin io bit home         "true starts the Drives internal home procedure, connect this to joint.x.index-enable pin";
pin out bit stat_homed  "true indicates that the Drive is internaly homed";
pin out bit stat_homing "true indicates that the Drives homing procedure is running";
Auxilary IOs
------------
pin out bit stat_switchon_ready   "Drive in CiA State: ready to switch on";
pin out bit stat_switched_on      "Drive in CiA State: switched on";
pin out bit stat_op_enabled       "Drive in CiA State: Operation enabled";
pin out bit stat_voltage_enabled  "Drive in CiA State: switched on, Voltage enabled";
pin out bit stat_fault            "Drive hast the fault bit set";
pin out bit stat_quick_stop       "Drive in State: Quick Stop";
pin out bit stat_switchon_disabled  "Drive in CiA State: Switch on disabled";
pin out bit stat_warning          "Drive has the warning bit set";
pin out bit stat_remote           "Drive in State remote / bus operation";
pin out bit stat_target_reached   "Drive has reached target position / velocity";
pin out bit opmode_no_mode        "Drive has no operation Mode set";
pin out bit opmode_homing         "Drive in Mode Homing";
pin out bit opmode_cyclic_position  "Drive in Mode Cyclic synchronus Position";
pin out bit opmode_cyclic_velocity  "Drive in Mode Cyclic synchronus Velocity";

pin in bit fault_reset  "true, sends fault reset command to the Drive";

parameters
----------
param rw float pos_scale    "increments per machine unit";
param rw float velo_scale   "velocity in machine units per 1 Motor revolution";
param rw bit auto_fault_reset "true resets an actual Drive Fault automatically at the next enable Signal";
param rw bit csp_mode "true= CS Position Mode, false= CS Velocity Mode, is only recognized at Linuxcnc Startup, default true";

*/

typedef union
{
  struct
  {
    unsigned char SwitchOn        : 1;  // 00
    unsigned char EnableVoltage   : 1;  // 01
    unsigned char QuickStop       : 1;  // 02
    unsigned char EnableOperation : 1;  // 03
    unsigned char StartHome       : 1;  // 04 not used in CSP or homing
    unsigned char bit5            : 1;  // 05 not used in CSP or homing
    unsigned char bit6            : 1;  // 06 not used in CSP or homing
    unsigned char Faultreset      : 1;  // 07
    unsigned char Timeout         : 1;  // 08
    unsigned char bit9            : 1;  // 09 not used in any mode
    unsigned char keep            : 6;  // 10-15 not used in any mode
  }b;
    unsigned int Word;
}Control_t;

typedef union
{
  struct
  {
    unsigned char ReadyToSwitchOn  : 1;  // 00
    unsigned char SwitchOn         : 1;  // 01
    unsigned char OperationEnabled : 1;  // 02
    unsigned char Fault            : 1;  // 03
    unsigned char VoltageEnabled   : 1;  // 04
    unsigned char QuickStop        : 1;  // 05
    unsigned char SwitchOnDisabled : 1;  // 06
    unsigned char Warning          : 1;  // 07
    unsigned char keep1            : 1;  // 08
    unsigned char Remote           : 1;  // 09
    unsigned char TargetReached    : 1;  // 10
    unsigned char bit11            : 1;  // 11
    unsigned char bit12            : 1;  // 12
    unsigned char keep2            : 3;  // 13-15
  }b;
  unsigned int Word;
}Status_t;


typedef struct {
  bool         homing;               // OUT pin
  bool         homed;                // OUT pin
  bool         home_sw;              // IN  pin
  bool         index_enable;         // IO  pin
  bool         at_home;
  bool         sync_final_move;      // joints with neg sequence
  bool         joint_in_sequence;
  int          pause_timer;
  double       home_offset;          // intfc, updateable
  double       home;                 // intfc, updateable
  double       home_final_vel;       // intfc
  double       home_search_vel;      // intfc
  double       home_latch_vel;       // intfc
  int          home_flags;           // intfc
  int          home_sequence;        // intfc, updateable
  bool         volatile_home;        // intfc
  bool         home_is_synchronized;
  double       cia_control;
  double       cia_status;
  unsigned int opmode_display;
  unsigned int drv_actual_position;
  unsigned int drv_actual_velocity;
  unsigned int drv_target_position;
  unsigned int drv_target_velocity;
  bool         drv_fault;
  float        pos_cmd;
  float        vel_cmd;
  unsigned int enable;
  bool         enable_old;
  unsigned int target_pos;
  unsigned int target_vel;
  unsigned int pos_fb;
  unsigned int velocity_fb;
  unsigned int opmode;
  bool         start_homing;
  bool         stat_homed;
  bool         stat_homed_old;
  bool         stat_homing;
  float        pos_scale;
  float        vel_scale;
  bool         auto_fault_reset;
  bool         csp_mode; // = 1;
  bool         stat_switchon_ready;
  bool         stat_switched_on;
  bool         stat_op_enabled;
  bool         stat_voltage_enabled;
  bool         stat_fault;
  bool         stat_quick_stop;
  bool         stat_switchon_disabled;
  bool         stat_warning;
  bool         stat_remote;
  bool         stat_target_reached;
  bool         opmode_no_mode;
  bool         opmode_homing;
  bool         opmode_cyclic_position;
  bool         opmode_cyclic_velocity;
  float        pos_scale_rcpt;
  float        velo_scale_old;
  float        pos_scale_old;
  float        velo_scale_rcpt;
  bool         init_pos;
  bool         pos_mode;
  bool         init_pos_mode;
  bool         fault_reset;
  bool         auto_fault_reset_delay;
  cia_home_state_t home_state;
  Status_t     Status;
  Control_t    Control;
#ifdef DEBUG
  bool         heartbeat;
#endif
} home_local_data;

enum opmode{PositionMode = 1, VelocityMode = 3, HomeMode = 6, DynamicMode = 8};

static clock_t last_time = 0;
static float   last_f_period = 0;
static  home_local_data H[EMCMOT_MAX_JOINTS];
static char *home_parms;
RTAPI_MP_STRING(home_parms,"CIA402 home parms");

// data for per-joint homing-specific hal pins:
typedef struct {
    hal_bit_t *home_sw;            // home switch input
    hal_bit_t *homing;             // joint is homing
    hal_bit_t *homed;              // joint is homed
    hal_bit_t *index_enable;       // motmod sets: request reset on index
                                   //        encoder clears: index arrived
    // cia402 homing
    hal_bit_t *csp_mode;           // true= CS Position Mode, false= CS Velocity Mode, is only recognized at Linuxcnc Startup
    hal_u32_t *cia_control;        // 0x6040 cia402 control word
    hal_u32_t *cia_status;         // 0x6041 cia402 status word
    hal_s32_t *cia_target_pos;     // 0x607A cia402 Target Position
    hal_s32_t *cia_target_vel;     // 0x60FF cia402 Target Velocity
    hal_s32_t *cia_opmode;         // 0x6060 cia402 opmode
    hal_s32_t *cia_current_pos;    // 0x6064 0x6064 cia402 Current Position
    hal_s32_t *cia_current_vel;    // 0x606C cia402 Current Velocity
    hal_s32_t *cia_opmode_display; // 0x6061 cia402 Opmode Display
    hal_s32_t *cia_drv_actual_position;
    hal_s32_t *cia_drv_actual_velocity;
    hal_s32_t *cia_enable;
    float     *pos_cmd;
    float     *vel_cmd;
    hal_s32_t *cia_drv_target_position;
    hal_s32_t *cia_drv_target_velocity;
    bool      *drv_fault;
    hal_s32_t *cia_pos_fb;
    hal_s32_t *cia_velocity_fb;
    hal_s32_t *cia_start_homing;
    hal_bit_t *cia_stat_homed;
    hal_bit_t *cia_stat_homed_old;
    hal_bit_t *cia_stat_homing;
    float     *cia_pos_scale;      // "increments per machine unit";
    float     *cia_vel_scale;      //"velocity in machine units per 1 Motor revolution";
    hal_bit_t *cia_auto_fault_reset;
    hal_bit_t *cia_csp_mode;
    hal_bit_t *stat_switchon_ready;
    hal_bit_t *stat_switched_on;
    hal_bit_t *stat_op_enabled;
    hal_bit_t *stat_voltage_enabled;
    hal_bit_t *stat_fault;
    hal_bit_t *stat_quick_stop;
    hal_bit_t *stat_switchon_disabled;
    hal_bit_t *stat_warning;
    hal_bit_t *stat_remote;
    hal_bit_t *stat_target_reached;
    hal_bit_t *opmode_no_mode;
    hal_bit_t *opmode_homing;
    hal_bit_t *opmode_cyclic_position;
    hal_bit_t *opmode_cyclic_velocity;
    float     *pos_scale_rcpt;
    float     *velo_scale_old;
    float     *pos_scale_old;
    float     *velo_scale_rcpt;
    bool      *init_pos;
    bool      *pos_mode;
    bool      *init_pos_mode;
    cia_home_state_t *home_state;
    bool      *fault_reset;
    bool      *auto_fault_reset_delay;
#ifdef DEBUG
    bool      *heartbeat;
#endif

} one_joint_home_data_t;

typedef struct {
    one_joint_home_data_t jhd[EMCMOT_MAX_JOINTS];
} all_joints_home_data_t;

static all_joints_home_data_t *joint_home_data = 0;


// rtapi_app_main() supplied by halcompile
// EXTRA_SETUP is executed before rtapi_app_main()
EXTRA_SETUP() {
    int jno;
    if (!home_parms) {home_parms = "no_home_parms";}
    rtapi_print("@@@%s:%s: home_parms=%s\n",__FILE__,__FUNCTION__,home_parms);

    for(jno =0;jno  < EMCMOT_MAX_JOINTS; jno++){
       //cia402 initialize variables
       H[jno].pos_scale = 1.0;
       H[jno].pos_scale_old = H[jno].pos_scale + 1.0;
       H[jno].pos_scale_rcpt = 1.0;
       H[jno].vel_scale = 1.0;
       H[jno].velo_scale_old = H[jno].vel_scale + 1.0;
       H[jno].velo_scale_rcpt = 1.0;
       H[jno].auto_fault_reset = 1;
       H[jno].csp_mode = 1;
       H[jno].home_state = HOME_TRIGGER;
       return 0;
    }
    if (last_time == 0)
        last_time = clock();
}

// retrieved from motmod.so:
static emcmot_config_t *emcmotConfig;
static emcmot_joint_t  *joints;

void check_scales(hal_float_t *scale,float *scale_old, double *scale_rcpt) {
  // check for change in scale value
  if (*scale != *scale_old) {
    // scale value has changed, test and update it
    if ((*scale < 1e-20) && (*scale > -1e-20)) {
      // value too small, divide by zero is a bad thing
      *scale = 1.0;
    }
    // save new scale to detect future changes
    *scale_old = *scale;
    // we actually want the reciprocal
    *scale_rcpt = 1.0 / *scale;
  }
}

//========================================================
// motmod function ptrs for functions called BY homecomp:
static void(*SetRotaryUnlock)(int,int);
static int (*GetRotaryIsUnlocked)(int);

//========================================================
// functions ptrs received from motmod:
void homeMotFunctions(void(*pSetRotaryUnlock)(int,int)
                     ,int (*pGetRotaryIsUnlocked)(int)
                     )
{
    SetRotaryUnlock     = *pSetRotaryUnlock;
    GetRotaryIsUnlocked = *pGetRotaryIsUnlocked;
}

// emcmot pointers received from motmod
void homeMotData(emcmot_config_t * pconfig
                ,emcmot_joint_t  * pjoints
                )
{
    emcmotConfig = pconfig;
    joints       = pjoints;
}
//========================================================



void cia_read(int jno, one_joint_home_data_t *addr)
{

  clock_t t_period;  // period between call in clocks
  float f_period;    // period in seconds
  clock_t period;    // we need to make our own period variable as it does not exist in this kind of component
  
  t_period = clock() - last_time;
  period = t_period * (CLOCKS_PER_SEC / 1e+9);  // convert to nanoseconds
  f_period = (float)t_period * ((float) t_period/(float)CLOCKS_PER_SEC);
  last_time += t_period;

  H[jno].Status.Word = *addr->cia_status; // copy to union structure to decode bitmap
  // check for change in scale value
  check_scales(&H[jno].pos_scale, &H[jno].pos_scale_old, &H[jno].pos_scale_rcpt);
  check_scales(&H[jno].vel_scale, &H[jno].velo_scale_old, &H[jno].velo_scale_rcpt);

	// read position feedback
	H[jno].pos_fb = ((double)H[jno].drv_actual_position) * H[jno].pos_scale_rcpt;
	if(H[jno].home_state == HOME_SEEKING){
		H[jno].pos_fb = H[jno].pos_cmd;    // this is important as it "eats" the following errors when the drives moves without lcnc control
	}
	// read velocity feedback
	H[jno].velocity_fb = ((double)H[jno].drv_actual_velocity) * H[jno].velo_scale_rcpt;

 // read Modes of Operation
  H[jno].opmode_no_mode = (H[jno].opmode_display == OPMODE_NONE);
  H[jno].opmode_homing = (H[jno].opmode_display == OPMODE_HOMING);
  H[jno].opmode_cyclic_velocity = (H[jno].opmode_display == OPMODE_CYCLIC_VELOCITY);
  H[jno].opmode_cyclic_position = (H[jno].opmode_display == OPMODE_CYCLIC_POSITION);

  // read status

  H[jno].stat_switchon_ready     = H[jno].Status.b.ReadyToSwitchOn;  // (statusword >> 0) & 1;
  H[jno].stat_switched_on         = H[jno].Status.b.SwitchOn;         //(statusword >> 1) & 1;
  H[jno].stat_op_enabled         = H[jno].Status.b.OperationEnabled; //(statusword >> 2) & 1;
  H[jno].stat_fault              = H[jno].Status.b.Fault;            //(statusword >> 3) & 1;
  H[jno].stat_voltage_enabled    = H[jno].Status.b.VoltageEnabled;   //(statusword >> 4) & 1;
  H[jno].stat_quick_stop         = H[jno].Status.b.QuickStop;        //(statusword >> 5) & 1;
  H[jno].stat_switchon_disabled  = H[jno].Status.b.SwitchOnDisabled; //(statusword >> 6) & 1;
  H[jno].stat_warning            = H[jno].Status.b.Warning;          //(statusword >> 7) & 1;
  H[jno].stat_remote             = H[jno].Status.b.Remote;           //(statusword >> 9) & 1;
  if(H[jno].opmode_cyclic_position || H[jno].opmode_cyclic_velocity) {
    H[jno].stat_target_reached   = H[jno].Status.b.TargetReached;   //(statusword >> 10) & 1;
  } else {
      H[jno].stat_target_reached = 0;
  }
  if (H[jno].opmode_homing) {
    H[jno].stat_homed    = (H[jno].Status.b.TargetReached  && H[jno].Status.b.bit12); //stat_homed    = ((statusword >> 10) & 1) && ((statusword >> 12) & 1);
    H[jno].stat_homing   = !H[jno].stat_homed && !H[jno].Status.b.TargetReached;
  }
  // update fault output
  if (H[jno].auto_fault_reset_delay > 0) {
     H[jno].auto_fault_reset_delay -= period;
     H[jno].drv_fault = 0;
  } else {
     H[jno].drv_fault = H[jno].stat_fault && H[jno].enable;
  }
#ifdef DEBUG
  if(last_f_period > HEARTBEAT)  //toggle the heartbeat
     H[jno].heartbeat ^= 1;
  if(jno == EMCMOT_MAX_JOINTS){  // last joint so increment the heartbeat and clear if necessary
      if(last_f_period > HEARTBEAT)
        last_f_period = 0;
      else
        last_f_period += f_period;

  }
#endif
}


void cia_write(int jno)
{
  int enable_edge;

  //init opmode
    if (!H[jno].init_pos ==  H[jno].pos_mode) {
      H[jno].pos_mode = H[jno].csp_mode;
      H[jno].init_pos_mode = 1;
  }


  // detect enable edge
  enable_edge = H[jno].enable && !H[jno].enable_old;
  H[jno].enable_old = H[jno].enable;


  // write control register
  H[jno].Control.b.QuickStop = 1; // quick stop is not supported  - might need to review this
  if (H[jno].stat_fault) {
    H[jno].home = 0;
    if (H[jno].fault_reset) {
      //controlword |= (1 << 7); fault reset
      H[jno].Control.b.Faultreset = 1;
    }
    if (H[jno].auto_fault_reset && enable_edge) {
      H[jno].auto_fault_reset_delay = FAULT_AUTORESET_DELAY_NS;
      //controlword |= (1 << 7);  fault reset
      H[jno].Control.b.Faultreset = 1;
    }
  } else {
    if (H[jno].enable) {
      H[jno].Control.b.EnableVoltage = 1;       //controlword |= (1 << 1);  enable voltage
      if (H[jno].stat_switchon_ready) {
        H[jno].Control.b.SwitchOn = 1;          //controlword |= (1 << 0);  switch on
        if (H[jno].stat_switched_on) {
          H[jno].Control.b.EnableOperation = 1; //controlword |= (1 << 3);  enable op
        }
      }
    }
  }

  // write position command
  H[jno].drv_target_position = (int32_t) (H[jno].pos_cmd * H[jno].pos_scale);
  // write velocity command
  H[jno].drv_target_velocity = (int32_t) (H[jno].vel_cmd * H[jno].vel_scale);

  // OP Mode
  // set to position mode
  if (H[jno].stat_voltage_enabled && !H[jno].start_homing ) {
    H[jno].opmode = OPMODE_CYCLIC_POSITION;
  }
  // set velo mode
  if (!H[jno].stat_voltage_enabled && !!H[jno].pos_mode && !H[jno].start_homing) {
    H[jno].opmode = OPMODE_CYCLIC_VELOCITY;
  }


 if (H[jno].start_homing) {
  	switch (H[jno].home_state){
  		case HOME_TRIGGER:
        // Homing has been requested
  			H[jno].opmode  = OPMODE_HOMING;
  			H[jno].home_state = HOME_CONFIRM;
  			break;
  		case HOME_CONFIRM:
  			if (H[jno].opmode_homing) {
          // Homing request has been accepted by drive
          H[jno].Control.b.StartHome  = 1;
  				H[jno].home_state = HOME_SEEKING;
  			}
  			break;
  		case HOME_SEEKING:
  		  if(H[jno].stat_homed){
           // Drive has been homed, reset start_homing and state machine
  			   H[jno].start_homing = 0;
  			   H[jno].home_state =  HOME_TRIGGER;
  			}
  		    break;
  	}
    H[jno].stat_homed_old = H[jno].stat_homed;
    H[jno].cia_control =  H[jno].Control.Word;
  }

  H[jno].cia_control              =  H[jno].Control.Word;
/*

  H[jno].cia_target_pos           =
  H[jno].cia_target_vel           =
  H[jno].cia_stat_homed           =
  H[jno].cia_opmode               =
  H[jno].cia_pos_scale            =
  H[jno].cia_vel_scale            =
  H[jno].cia_stat_homed           =
  H[jno].cia_start_homing         =
  H[jno].stat_switchon_ready      =
  H[jno].stat_switched_on         =
  H[jno].stat_op_enabled          =
  H[jno].stat_voltage_enabled     =
  H[jno].cia_stat_homing          =
  H[jno].stat_fault               =
  H[jno].stat_quick_stop          =
  H[jno].stat_switchon_disabled   =
  H[jno].stat_warning             =
  H[jno].stat_remote              =
  H[jno].stat_target_reached      =
  H[jno].opmode_no_mode           =
  H[jno].opmode_homing            =
  H[jno].opmode_cyclic_position   =
  H[jno].opmode-cyclic-velocity   =
*/
}


static int makepins(int id,int njoints)
{
    // home_pins needed to work with configs expecting them:
    int jno,retval;
    one_joint_home_data_t *addr;

    joint_home_data = hal_malloc(sizeof(all_joints_home_data_t));
    if (joint_home_data == 0) {
        rtapi_print_msg(RTAPI_MSG_ERR, "HOMING: all_joints_home_data_t malloc failed\n");
        return -1;
    }

    retval = 0;
    for (jno = 0; jno < njoints; jno++) {
        addr = &(joint_home_data->jhd[jno]);

        retval += hal_pin_bit_newf(HAL_IN, &(addr->home_sw), id,
                                  "joint.%d.home-sw-in", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->homing), id,
                                  "joint.%d.homing", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->homed), id,
                                  "joint.%d.homed", jno);
        retval += hal_pin_s32_newf(HAL_OUT, &(addr->home_state), id,
                                  "joint.%d.home-state", jno);
        retval += hal_pin_bit_newf(HAL_IO, &(addr->index_enable), id,
                                  "joint.%d.index-enable", jno);
        // cia402 pins
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->cia_control), id,
                                  "joint.%d.cia-control", jno);
        retval += hal_pin_bit_newf(HAL_IN, &(addr->cia_status), id,
                                  "joint.%d.cia-status", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->cia_target_pos), id,
                                  "joint.%d.cia-target-pos", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->cia_target_vel), id,
                                  "joint.%d.cia-target-vel", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->cia_opmode), id,
                                  "joint.%d.cia-opmode", jno);
        retval += hal_pin_float_newf(HAL_IO, &(addr->pos_cmd), id,
                                  "joint.%d.cia-pos-cmd", jno);

        retval += hal_pin_float_newf(HAL_IO, &(addr->vel_cmd), id,
                                  "joint.%d.cia-vel-cmd", jno);

        retval += hal_pin_float_newf(HAL_IO, &(addr->cia_pos_scale), id,
                                  "joint.%d.cia-pos-scale", jno);
        retval += hal_pin_float_newf(HAL_IO, &(addr->cia_vel_scale), id,
                                  "joint.%d.cia-vel-scale", jno);

        retval += hal_pin_s32_newf(HAL_IN, &(addr->cia_drv_actual_position), id,
                                  "joint.%d.cia-drv-actual-position", jno);
        retval += hal_pin_s32_newf(HAL_IN, &(addr->cia_drv_actual_velocity), id,
                                  "joint.%d.cia-drv-actual-velocity", jno);
        retval += hal_pin_bit_newf(HAL_IN, &(addr->cia_enable), id,
                                  "joint.%d.cia-enable", jno);;
        retval += hal_pin_s32_newf(HAL_IO, &(addr->cia_start_homing), id,
                                  "joint.%d.cia-start-homing", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->cia_stat_homed), id,
                                  "joint.%d.cia-stat-homed", jno);
        // Auxilliary IO's
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->stat_switchon_ready), id,
                                  "joint.%d.cia-stat-switchon_ready", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->stat_switched_on), id,
                                  "joint.%d.cia-stat-switched-on", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->stat_op_enabled), id,
                                  "joint.%d.cia-stat-op-enabled", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->stat_voltage_enabled), id,
                                  "joint.%d.cia-stat-voltage-enabled", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->cia_stat_homing), id,
                                  "joint.%d.cia-stat-homing", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->stat_fault), id,
                                  "joint.%d.cia-stat-fault", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->stat_quick_stop), id,
                                  "joint.%d.cia-stat-quick-stop", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->stat_switchon_disabled), id,
                                  "joint.%d.cia-stat-switchon-disabled", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->stat_warning), id,
                                  "joint.%d.cia-stat-warning", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->stat_remote), id,
                                  "joint.%d.cia-stat-remote", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->stat_target_reached), id,
                                  "joint.%d.cia-stat-target-reached", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->opmode_no_mode), id,
                                  "joint.%d.cia-opmode-no-mode", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->opmode_homing), id,
                                  "joint.%d.cia-opmode-homing", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->opmode_cyclic_position), id,
                                  "joint.%d.cia-opmode-cyclic-position", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->opmode_cyclic_velocity), id,
                                  "joint.%d.cia-opmode-cyclic-velocity", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->pos_mode), id,
                                  "joint.%d.cia-pos-mode", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->fault_reset), id,
                                  "joint.%d.cia-fault_reset", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->drv_fault), id,
                                  "joint.%d.cia-drv_fault", jno);
#ifdef DEBUG
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->heartbeat), id,
                                  "joint.%d.cia-heartbeat", jno);
#endif

    }
    rtapi_print_msg(RTAPI_MSG_ERR, "HOMING: make pins completed\n");
    return retval;
}

//========================================================
// All functions required for homing api
// For homecomp.comp: most are skeleton

bool do_homing(void)                                 {return 1;}
void do_homing_sequence(void)                        {return;}
bool get_allhomed()                                  {return 1;}
bool get_homed(int jno)                              {return 1;}
bool get_home_is_idle(int jno)                       {return 1;}
bool get_home_is_synchronized(int jno)               {return 0;}
bool get_home_is_volatile(int jno)                   {return 0;}
bool get_home_needs_unlock_first(int jno)            {return 0;}
int  get_home_sequence(int jno)                      {return 0;}
home_sequence_state_t get_home_sequence_state() {return HOME_SEQUENCE_IDLE;}
bool get_homing(int jno)                             {return 0;}
bool get_homing_at_index_search_wait(int jno)        {return 0;}
bool get_homing_is_active()                          {return 0;}
int  homing_init(int id,int njoints)          {return makepins(id,njoints);}
bool get_index_enable(int jno)                       {return 0;}

  void write_homing_out_pins(int njoints)
{
    int jno;
    one_joint_home_data_t *addr;
    for (jno = 0; jno < njoints; jno++) {
        cia_write(jno);
        addr = &(joint_home_data->jhd[jno]);
        *(addr->homing)                  = H[jno].homing;       // OUT
        *(addr->homed)                   = H[jno].homed;        // OUT
        *(addr->home_state)              = H[jno].home_state;   // OUT
        *(addr->index_enable)            = H[jno].index_enable; // IO
        *(addr->cia_control)             = H[jno].cia_control;  // OUT;
        *(addr->cia_target_pos)          = H[jno].target_pos;
        *(addr->cia_target_vel)          = H[jno].target_vel;
        *(addr->cia_stat_homed)          = H[jno].stat_homed;
        *(addr->cia_stat_homed_old)      = H[jno].stat_homed_old;
        *(addr->cia_opmode)              = H[jno].opmode;
        *(addr->cia_pos_scale)           = H[jno].pos_scale;
        *(addr->cia_vel_scale)           = H[jno].vel_scale;
        *(addr->cia_start_homing)        = H[jno].start_homing;
        *(addr->stat_switchon_ready)     = H[jno].stat_switchon_ready;
        *(addr->stat_switched_on)        = H[jno].stat_switched_on;
        *(addr->stat_op_enabled)         = H[jno].stat_op_enabled;
        *(addr->stat_voltage_enabled)    = H[jno].stat_voltage_enabled;
        *(addr->cia_stat_homing)         = H[jno].stat_homing;
        *(addr->stat_fault)              = H[jno].stat_fault;
        *(addr->stat_quick_stop)         = H[jno].stat_quick_stop;
        *(addr->stat_switchon_disabled)  = H[jno].stat_switchon_disabled;
        *(addr->stat_warning)            = H[jno].stat_warning;
        *(addr->stat_remote)             = H[jno].stat_remote;
        *(addr->stat_target_reached)     = H[jno].stat_target_reached;
        *(addr->opmode_no_mode)          = H[jno].opmode_no_mode;
        *(addr->opmode_homing)           = H[jno].opmode_homing;
        *(addr->opmode_cyclic_position)  = H[jno].opmode_cyclic_position;
        *(addr->opmode_cyclic_velocity)  = H[jno].opmode_cyclic_velocity;
        *(addr->pos_mode)                = H[jno].pos_mode;
        *(addr->fault_reset)             = H[jno].fault_reset;
        *(addr->drv_fault)               = H[jno].drv_fault;
#ifdef DEBUG
        *(addr->heartbeat)               = H[jno].heartbeat;

#endif
        // TODO -- Need to write out the rest of the CIA pins
    }
    return;
}

void read_homing_in_pins(int njoints)
{
    int jno;
    one_joint_home_data_t *addr;
    for (jno = 0; jno < njoints; jno++) {
        addr = &(joint_home_data->jhd[jno]);
        H[jno].index_enable = *(addr->index_enable); // IO
        // cia read code follows
        H[jno].cia_status = *(addr->cia_status);      // IN

        // TODO -- Need to read in the rest of the CIA pins

        cia_read(jno, addr);
    }

  return;
}

void set_home_abort(int jno)                         {return;}
void set_home_idle(int jno)                          {return;}
void set_home_sequence_state(home_sequence_state_t s_state) {return;}
void set_home_start(int jno)                         {return;}
void set_joint_at_home(int jno, bool value)          {return;}
void set_joint_homed(int jno,bool value)             {return;}
void set_joint_homing(int jno,bool value)            {return;}
void set_joint_homing_params(int    jno,
                             double offset,
                             double home,
                             double home_final_vel,
                             double home_latch_vel,
                             double home_search_vel,
                             int    home_flags,
                             int    home_sequence,
                             bool   volatile_home
                             )                       {return;}
void update_joint_homing_params (int    jno,
                                 double offset,
                                 double home,
                                 int    home_sequence
                                )                    {return;}


//========================================================
// all home functions for homing api
EXPORT_SYMBOL(homeMotFunctions);
EXPORT_SYMBOL(homeMotData);

EXPORT_SYMBOL(do_homing);
EXPORT_SYMBOL(do_homing_sequence);
EXPORT_SYMBOL(get_allhomed);
EXPORT_SYMBOL(get_homed);
EXPORT_SYMBOL(get_home_is_idle);
EXPORT_SYMBOL(get_home_is_synchronized);
EXPORT_SYMBOL(get_home_is_volatile);
EXPORT_SYMBOL(get_home_needs_unlock_first);
EXPORT_SYMBOL(get_home_sequence);
EXPORT_SYMBOL(get_home_sequence_state);
EXPORT_SYMBOL(get_homing);
EXPORT_SYMBOL(get_homing_at_index_search_wait);
EXPORT_SYMBOL(get_homing_is_active);
EXPORT_SYMBOL(get_index_enable);
EXPORT_SYMBOL(homing_init);
EXPORT_SYMBOL(read_homing_in_pins);
EXPORT_SYMBOL(set_home_abort);
EXPORT_SYMBOL(set_home_idle);
EXPORT_SYMBOL(set_home_sequence_state);
EXPORT_SYMBOL(set_home_start);
EXPORT_SYMBOL(set_joint_at_home);
EXPORT_SYMBOL(set_joint_homed);
EXPORT_SYMBOL(set_joint_homing);
EXPORT_SYMBOL(set_joint_homing_params);
EXPORT_SYMBOL(update_joint_homing_params);
EXPORT_SYMBOL(write_homing_out_pins);
